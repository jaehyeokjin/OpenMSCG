
from cg import *
import pickle, math

def main(*args, **kwargs):
    
    # parse argument
    
    parser = CLIParser(description='Dump or plot tables from force-matching results.', formatter_class=argparse.ArgumentDefaultsHelpFormatter, fromfile_prefix_chars='@', add_help=False)
    
    group = parser.add_argument_group('General arguments')
    group.add_argument("-h", "--help", action="help", help="show this help message and exit")
    group.add_argument("-v", "--verbose", metavar='L', type=int, default=0, help="screen verbose level")
    
    group = parser.add_argument_group('Required arguments')
    group.add_argument("--file",  metavar='file', type=str, help="matrix file", required=True)
    
    group = parser.add_argument_group('Optional arguments')
    group.add_argument("--dump", metavar='', type=str, help="dump a LAMMPS table file, in format of [table_name,xmin,xmax,dx]", action='append')
    group.add_argument("--plot", metavar='', type=str, help="plot table, in format of [table_name,xmin,xmax,dx]")
    
    if len(args)>0 or len(kwargs)>0:
        args = parser.parse_inline_args(*args, **kwargs)
    else:
        args = parser.parse_args()

    # load matrix file
    
    matrix = pickle.load(open(args.file, 'rb'))
    
    screen.info('Matrix file loaded: ' + matrix['file'])
    screen.info('Generated by: %s (%s)' % (matrix['user'], matrix['time']))
    screen.info('Generated on: %s (os: %s)' % (matrix['host'], matrix['os']))
    screen.info('Working path: %s' % (matrix['path']))
    screen.info('The file contains %d coefficient tables:' % (len(matrix['tables'])))
    
    for name, tbl in matrix['tables'].items():
        screen.info(' * %-16s order=%-2d nbreak=%-4d xmin=%-5.2f xmax=%-5.2f' % (name + ':', tbl['order'], tbl['nbreak'], tbl['xmin'], tbl['xmax']))
    
    # dump LAMMPS table file
    
    def gen_table(table_line):
        
        w = table_line.split(',')
        tbl_name = w[0]
        
        if tbl_name not in matrix['tables']:
            screen.error("table [%s] doesn't exist." % (tbl_name))
            return None
                
        tbl = matrix['tables'][tbl_name]
        xmin = float(w[1]) if len(w)>1 else tbl['xmin']
        xmax = float(w[2]) if len(w)>2 else tbl['xmax']
        dx   = float(w[3]) if len(w)>3 else tbl['dx']
        
        screen.info('Produce table [%s] ...' % (tbl_name))
        
        if xmin < tbl['xmin']:
            screen.error("invalid xmin value: %f" % (xmin))
            return None
        
        if xmax > tbl['xmax']:
            screen.error("invalid xmax value: %f" % (xmax))
            return None
            
        sp = BSpline(tbl['order'], tbl['dx'], tbl['xmin'], tbl['xmax'])
        n = math.floor((xmax - xmin)/dx)
        
        X = [xmin + dx * i for i in range(n)]
        F = sp.interpolate(xmin, dx, n, tbl['coeffs'])
        
        pot = 0
        U = [0.0] * n
        
        for i in range(1, n):
            U[i] = U[i-1] - 0.5 * dx * (F[i-1] + F[i])
        
        if tbl_name[:5] == 'Pair_':
            U0 = U[-1]
        else:
            U0 = min(U)
        
        U = [i - U0 for i in U]
        
        return [X, U, F]
    
    if args.dump is not None:
        for dump in args.dump:

            T = gen_table(dump)

            if T is None:
                continue

            tbl_name = dump.split(',')[0]
            n = len(T[0])
            txt = "# Table %s: id, r, potential, force\n\n" % (tbl_name)
            txt += "_".join(tbl_name.split("_")[1:]) + "\n"
            txt += "N %d R %f %f\n\n" % (n, T[0][0], T[0][-1])

            for i in range(n):
                txt += "%d %f %f %f\n" % (i+1, T[0][i], T[1][i], T[2][i])

            with open(tbl_name + ".table", "w") as f:
                f.write(txt)
    
    
    if args.plot is not None:
        
        T = gen_table(args.plot)
        
        if T is not None:
            import matplotlib.pyplot as plt
            plt.plot(T[0], T[2], label='Force - Kcal/mol/angstrom')
            plt.plot(T[0], T[1], label='Potential Energy - Kcal/mol')
            plt.legend(loc='upper right')
            plt.title(args.plot.split(',')[0])
            plt.show()
    
    return



if __name__ == '__main__':
    main()
